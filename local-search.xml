<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32标准库_02 | 从按键开始认识状态机编程 </title>
    <link href="/2020/06/20/stm32%E6%A0%87%E5%87%86%E5%BA%93_02%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8C%89%E9%94%AE/"/>
    <url>/2020/06/20/stm32%E6%A0%87%E5%87%86%E5%BA%93_02%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8C%89%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍如何利用状态机来编写按键检测实验，希望能给人以收获。</p><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>使用MDK5.25版本，芯片包为STM32F4系列。</p><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>开发板：一块多按键的开发板，本实验采用有三个按键的stm32F407VGT6开发板，是一款大容量芯片，最高能跑168MHz,比F103的72M快了一倍多。</p><p>烧录器：STlink或者Jlink。</p><h2 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h2><p>和STM32标准库_01 | 搭建自己的程序框架，思路是一样的，具体可以看我的截图，从正点原子的资料中拷贝相关源文件。<br><img src="/images/stm32_02/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/3.png" srcset="/img/loading.gif" alt=""></p><p>因为我的开发板用的是25M的外部晶振，所以要修改两个地方，达到利用外部晶振倍频到168M作为系统时钟。</p><p>1.修改的地方之一：stm32f4xx.h里面的HSE_VALUE，系统默认采用外部8M晶振，所 以 #define HSE_VALUE    ((uint32_t)8000000) ，现把它修改 为 #define HSE_VALUE    ((uint32_t)25000000)<br><img src="/images/stm32_02/5.png" srcset="/img/loading.gif" alt=""></p><p>2.修改的地方之二：系统通过PLL倍频到168M，所以在配置PLL的时候，也需要作相应的修改。在system_stm32f4xx.c里，需要 把PLL_M修改为25，不然会超频使STM32不能正常工作，常见表现为掉进HardFault_Handler()中。<br><img src="/images/stm32_02/4.png" srcset="/img/loading.gif" alt=""></p><p>滴答定时器的初始化是和F103一样的，但是GPIO的初始化有些区别，F407挂载到高速时钟总线AHB1上，翻转速度最高能够达到100M，意味着可以更高速的进行一些协议的通信，还有就是把设置IO的输出输出模式和上下拉模式分离了出来，多了GPIO_OType和GPIO_PuPd需要配置。<br><img src="/images/stm32_02/6.png" srcset="/img/loading.gif" alt=""></p><p>测试一下<br><img src="/images/stm32_02/7.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/8.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-代码编写"><a href="#3-代码编写" class="headerlink" title="3.代码编写"></a>3.代码编写</h2><h3 id="1-状态机编程思想"><a href="#1-状态机编程思想" class="headerlink" title="1.状态机编程思想"></a>1.状态机编程思想</h3><p>其实很多项目里面多多少少都有状态机的影子，状态机又称有限状态机，任何事物只要拥有有限个状态，就能使用状态机的方式实现代码。例如门有两种状态，即开和关，还例如我们今天要写的按键轮询检测实验中，按键的状态可以分为四种，按键弹起的状态、按键按下抖动状态、按键按下状态和按键弹起抖动状态。<br><img src="/images/stm32_02/10.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-按键基础代码编写"><a href="#2-按键基础代码编写" class="headerlink" title="2.按键基础代码编写"></a>2.按键基础代码编写</h3><p>下面我们来编写代码，首先是按键的GPIO初始化，因为我们检测的是低电平，所以设置为上拉输入。<br><img src="/images/stm32_02/11.png" srcset="/img/loading.gif" alt=""></p><p>编写引脚电平获取函数。<br><img src="/images/stm32_02/12.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/13.png" srcset="/img/loading.gif" alt=""></p><p>关于按键编号，是声明在头文件的枚举<br><img src="/images/stm32_02/14.png" srcset="/img/loading.gif" alt=""></p><p>除了按键编号与按键状态的枚举外，还有一个键值的枚举，让我们保留按键是按下，长按还是松开等等。<br><img src="/images/stm32_02/15.png" srcset="/img/loading.gif" alt=""></p><p>声明了这些枚举后，我们得用实体去接收啊，如果是C++，就是创建对象了，当然了，C语言没有对象，所以我们创建一个结构体去接收。<br><img src="/images/stm32_02/16.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/17.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-按键轮询状态机代码编写"><a href="#3-按键轮询状态机代码编写" class="headerlink" title="3.按键轮询状态机代码编写"></a>3.按键轮询状态机代码编写</h3><p>先定义触发长按的时间为1s。<br><img src="/images/stm32_02/18.png" srcset="/img/loading.gif" alt=""></p><p>开始编写三个按键一起轮询的按键检测函数，利用状态机编程。<br><img src="/images/stm32_02/19.png" srcset="/img/loading.gif" alt=""></p><p>在按键弹起状态时，如果检测到引脚为低电平，则跳转到按键按键抖动状态。<br><img src="/images/stm32_02/20.png" srcset="/img/loading.gif" alt=""></p><p>在按键按键抖动状态里，如果检测到引脚为按下时的低电平，则跳转到按键按下状态，否则则返回按键弹起状态。<br><img src="/images/stm32_02/21.png" srcset="/img/loading.gif" alt=""></p><p>在按键按下状态里，会执行长按计数，如果小于触发长按的时间里，按键松开了，则进入按键弹起抖动状态，并且保留(按键按下的键值)；如果达到触发长按的时间，就会保存(按键长按的键值，并赋值长按状态，就能一直去等待按键松开)，如果按键松开就跳转到按键弹起抖动状态。<br><img src="/images/stm32_02/22.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/23.png" srcset="/img/loading.gif" alt=""></p><p>在按键弹起抖动状态下，检测按键是不是按键弹起状态，如果是则跳转到按键弹起状态。异常状态时按键切回按键弹起状态。<br><img src="/images/stm32_02/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-按键轮询状态机测试"><a href="#4-按键轮询状态机测试" class="headerlink" title="4.按键轮询状态机测试"></a>4.按键轮询状态机测试</h2><h3 id="1-测试流程"><a href="#1-测试流程" class="headerlink" title="1.测试流程"></a>1.测试流程</h3><p>按键1按下，把LED1,2,3点亮；按键2按下，把LED1,2,3熄灭；按键3长按，翻转LED1,2,3。<br><img src="/images/stm32_02/25.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/26.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-代码烧录"><a href="#2-代码烧录" class="headerlink" title="2.代码烧录"></a>2.代码烧录</h3><p><img src="/images/stm32_02/27.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-实验现象"><a href="#3-实验现象" class="headerlink" title="3.实验现象"></a>3.实验现象</h3><p><img src="/images/stm32_02/28.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/29.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>STM32标准库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32标准库_01 | 搭建自己的程序框架</title>
    <link href="/2020/06/07/stm32%E6%A0%87%E5%87%86%E5%BA%93_01%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA/"/>
    <url>/2020/06/07/stm32%E6%A0%87%E5%87%86%E5%BA%93_01%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍本人早期的基于STM32标准库的程序框架，希望能给人以收获。</p><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>使用MDK5.25版本，芯片包为STM32F1系列。</p><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>开发板：一块STM32F103C8T6开发板（FLASH:64kBytes,RAM:20kBytes），是一款中等容量的芯片。</p><p>烧录器：STlink或者Jlink。</p><h2 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h2><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><p>现在本地文件夹下创建4个文件夹，分别是APP（存放应用层代码），LIB（存放STM32标准库相关文件），CORE（存放STM内核与启动文件等），Project(存放工程相关文件)。</p><p><img src="/images/stm32_01/1.png" srcset="/img/loading.gif" alt=""></p><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>在MDK中新建工程，保存到刚刚创建的本地文件夹下的Project文件夹中，并选择STM32F103芯片。</p><p><img src="/images/stm32_01/2.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/3.png" srcset="/img/loading.gif" alt=""></p><p>后面会弹出选择其他驱动组件的界面，直接选择取消。</p><p><img src="/images/stm32_01/4.png" srcset="/img/loading.gif" alt=""></p><p>接着直接用正点原子战舰板资料（推荐下载，软硬件资料很全）里面的v3.5固件库，把工程需要的文件拷贝到本地文件夹中，如图示主要是拷贝到CORE和LIB文件夹。</p><p><img src="/images/stm32_01/5.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/6.png" srcset="/img/loading.gif" alt=""></p><p>我们的LIB文件夹直接拷贝STM32战舰的参考资料\STM32F1xx固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver文件夹下的inc和src这两个文件夹。</p><p><img src="/images/stm32_01/7.png" srcset="/img/loading.gif" alt=""></p><h4 id="在MDK中导入我们的文件夹结构"><a href="#在MDK中导入我们的文件夹结构" class="headerlink" title="在MDK中导入我们的文件夹结构"></a>在MDK中导入我们的文件夹结构</h4><p><img src="/images/stm32_01/8.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/9.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/10.png" srcset="/img/loading.gif" alt=""><br>在本地APP文件夹中添加main.c等文件夹（记得勾选显示文件拓展名），再添加到MDK中。<br><img src="/images/stm32_01/11.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/12.png" srcset="/img/loading.gif" alt=""></p><p>最后要指定一下头文件路径和添加全局属性的宏定义。</p><p><img src="/images/stm32_01/13.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/14.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-编写代码"><a href="#3-编写代码" class="headerlink" title="3.编写代码"></a>3.编写代码</h2><p>打开main.c添加main函数并编译</p><p><img src="/images/stm32_01/15.png" srcset="/img/loading.gif" alt=""></p><h3 id="框架代码编写"><a href="#框架代码编写" class="headerlink" title="框架代码编写"></a>框架代码编写</h3><p>（1）系统时基</p><p>当我们拿到一块STM板子的时候，我们得看它的外部晶振是多少M的（一般用8M的外部晶振），如果不是8M的晶振就需要修改stm32f10x.h和system_stm32f10x,c里的SetSysClockTo72()函数共两处地方。</p><p><img src="/images/stm32_01/16.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/17.png" srcset="/img/loading.gif" alt=""></p><p>开始编写systick.c和systick.h文件。</p><p><img src="/images/stm32_01/18.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/19.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/20.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/21.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/22.png" srcset="/img/loading.gif" alt=""></p><p>（2）编写LED程序用于测试</p><p>原理图<br><img src="/images/stm32_01/23.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/24.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/25.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/26.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/27.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/28.png" srcset="/img/loading.gif" alt=""></p><h3 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h3><p><img src="/images/stm32_01/29.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/30.png" srcset="/img/loading.gif" alt=""></p><h3 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h3><p><img src="/images/stm32_01/31.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>STM32标准库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
