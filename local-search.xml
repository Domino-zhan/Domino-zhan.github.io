<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STM32标准库_03 | 串口printf打印</title>
    <link href="/2020/06/26/stm32%E6%A0%87%E5%87%86%E5%BA%93_03%E4%B8%B2%E5%8F%A3printf%E6%89%93%E5%8D%B0/"/>
    <url>/2020/06/26/stm32%E6%A0%87%E5%87%86%E5%BA%93_03%E4%B8%B2%E5%8F%A3printf%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍STM32的调试利器，串口printf打印输出，希望能给人以收获。</p><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>使用MDK5.25版本，芯片包为STM32F4系列。</p><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>开发板：STM32F407VGT6开发板，是一款大容量芯片，最高能跑168MHz。</p><p>烧录器：STlink或者Jlink。</p><h2 id="2-工程搭建"><a href="#2-工程搭建" class="headerlink" title="2.工程搭建"></a>2.工程搭建</h2><p>直接复制上一篇代码，在工程栏加入<strong>/LIB/src</strong>文件夹下的串口库函数文件stm32f4xx_usart.c，在<strong>/APP</strong>文件夹下加入usart.c和usart.h文件并添加到MDK工程栏。<br><img src="/images/stm32_03/1.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/2.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/3.png" srcset="/img/loading.gif" alt=""></p><h3 id="开始编写串口初始化函数和重定义printf打印函数。"><a href="#开始编写串口初始化函数和重定义printf打印函数。" class="headerlink" title="开始编写串口初始化函数和重定义printf打印函数。"></a>开始编写串口初始化函数和重定义printf打印函数。</h3><p><img src="/images/stm32_03/4.png" srcset="/img/loading.gif" alt=""><br>在usart.c文件中添加串口初始化函数，F407和F103有些区别，1是串口挂载的时钟总线，2是F103对于串口TX和RX是分别初始化为复用推挽输出和上拉输入的。</p><pre><code class="hljs markdown">/*<span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-bullet">*</span>函 数 名: uart1_Init<span class="hljs-bullet">*</span>功能说明: 串口1初始化函数<span class="hljs-bullet">*</span>形    参: 1.bound（串口波特率）<span class="hljs-bullet">*</span>返 回 值: 无<span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span>*/ void uart1_Init(u32 bound)&#123;   //GPIO端口设置<span class="hljs-code">    GPIO_InitTypeDef GPIO_InitStructure;</span><span class="hljs-code">USART_InitTypeDef USART_InitStructure;</span><span class="hljs-code"></span><span class="hljs-code">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); //使能GPIOA时钟</span><span class="hljs-code">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);//使能USART1时钟</span> <span class="hljs-code">//串口1对应引脚复用映射</span><span class="hljs-code">GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1); //GPIOA9复用为USART1</span><span class="hljs-code">GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1); //GPIOA10复用为USART1</span><span class="hljs-code"></span><span class="hljs-code">//USART1端口配置</span><span class="hljs-code">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; //GPIOA9与GPIOA10</span><span class="hljs-code">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能</span><span class="hljs-code">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHz</span><span class="hljs-code">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出</span><span class="hljs-code">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉</span><span class="hljs-code">GPIO_Init(GPIOA,&amp;GPIO_InitStructure); //初始化PA9，PA10</span>   //USART1 初始化设置<span class="hljs-code">USART_InitStructure.USART_BaudRate = bound;//波特率设置</span><span class="hljs-code">USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式</span><span class="hljs-code">USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位</span><span class="hljs-code">USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位</span><span class="hljs-code">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制</span><span class="hljs-code">USART_InitStructure.USART_Mode =  USART_Mode_Tx;//收发模式</span><span class="hljs-code">    USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1</span><span class="hljs-code"></span><span class="hljs-code">    USART_Cmd(USART1, ENABLE);  //使能串口1 </span><span class="hljs-code">//USART_ClearFlag(USART1, USART_FLAG_TC);   //解决第一个字节丢失问题,如果第一个字节丢失可以加上这行</span>&#125;</code></pre><p>对于重定义printf函数有两种方法，一种是使用微库，一种是不是用微库（正点原子）使用的方法。</p><h4 id="1-使用微库重定义printf函数"><a href="#1-使用微库重定义printf函数" class="headerlink" title="1.使用微库重定义printf函数"></a>1.使用微库重定义printf函数</h4><p><img src="/images/stm32_03/5.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/6.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意：printf函数依赖于”stdio.h”,在使用的时候记得添加上”stdio.h”。</strong></p><p>如果是C++文件则修改成</p><p><img src="/images/stm32_03/7.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-不使用微库重定义printf函数"><a href="#2-不使用微库重定义printf函数" class="headerlink" title="2.不使用微库重定义printf函数"></a>2.不使用微库重定义printf函数</h4><p><strong>在原来的fputc函数的基础上再加入避免使用半主机模式的一些代码（参考正点原子）。</strong></p><p><img src="/images/stm32_03/8.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/9.png" srcset="/img/loading.gif" alt=""></p><p>可以参考这篇对于[半主机模式][1]的理解<br>[1]:<a href="http://www.stmcu.org.cn/module/forum/thread-598294-1-1.html" target="_blank" rel="noopener">http://www.stmcu.org.cn/module/forum/thread-598294-1-1.html</a></p><p><strong>小结:所谓重定义就是修改fputc函数的底层代码，修改成运行一次串口发送一个字节的数据。</strong></p><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h4><p><img src="/images/stm32_03/10.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/11.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/12.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-打印方案"><a href="#3-打印方案" class="headerlink" title="3.打印方案"></a>3.打印方案</h2><h3 id="编写打印代码"><a href="#编写打印代码" class="headerlink" title="编写打印代码"></a>编写打印代码</h3><p>于我而言，我个人把打印分成两种，一种是错误打印（一般用于else的后面，或者校验失败的地方），另一种就是常规打印，这些打印还可能遇到一些场景，例如我的单片机资源比较少，我就写程序的时候用一下，或者我想控制我的打印输出等等。</p><p><strong>直接上代码开讲</strong><br><img src="/images/stm32_03/13.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>USER_DEBUG</strong>是程序控制的开关，用于单片机资源比较少的时候，我们调试的时候用一下。</p><p><strong>Print_Switch</strong>是一个接口控制的开关，可用于远程网络或者本地串口修改，来开启或者关闭打印。</p><p>当然，我们还可以分很多级别的打印，希望各位举一反三。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="/images/stm32_03/14.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_03/15.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><strong>这个宏定义最好放在.h头文件中，方便其他.c文件，后续我会加在Dbg.c和Dbg.h中，对于逻辑复杂的状态机，用打印的方法是一个很好的调试手段，当然如果遇到死机，那得用仿真器Debug了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>STM32标准库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32标准库_02 | 从按键开始认识状态机编程 </title>
    <link href="/2020/06/20/stm32%E6%A0%87%E5%87%86%E5%BA%93_02%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8C%89%E9%94%AE/"/>
    <url>/2020/06/20/stm32%E6%A0%87%E5%87%86%E5%BA%93_02%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8C%89%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍如何利用状态机来编写按键检测实验，希望能给人以收获。</p><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>使用MDK5.25版本，芯片包为STM32F4系列。</p><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>开发板：一块多按键的开发板，本实验采用有三个按键的stm32F407VGT6开发板，是一款大容量芯片，最高能跑168MHz,比F103的72M快了一倍多。</p><p>烧录器：STlink或者Jlink。</p><h2 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h2><p>和STM32标准库_01 | 搭建自己的程序框架，思路是一样的，具体可以看我的截图，从正点原子的资料中拷贝相关源文件。<br><img src="/images/stm32_02/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/3.png" srcset="/img/loading.gif" alt=""></p><p>因为我的开发板用的是25M的外部晶振，所以要修改两个地方，达到利用外部晶振倍频到168M作为系统时钟。</p><p>1.修改的地方之一：stm32f4xx.h里面的HSE_VALUE，系统默认采用外部8M晶振，所 以 #define HSE_VALUE    ((uint32_t)8000000) ，现把它修改 为 #define HSE_VALUE    ((uint32_t)25000000)<br><img src="/images/stm32_02/5.png" srcset="/img/loading.gif" alt=""></p><p>2.修改的地方之二：系统通过PLL倍频到168M，所以在配置PLL的时候，也需要作相应的修改。在system_stm32f4xx.c里，需要 把PLL_M修改为25，不然会超频使STM32不能正常工作，常见表现为掉进HardFault_Handler()中。<br><img src="/images/stm32_02/4.png" srcset="/img/loading.gif" alt=""></p><p>滴答定时器的初始化是和F103一样的，但是GPIO的初始化有些区别，F407挂载到高速时钟总线AHB1上，翻转速度最高能够达到100M，意味着可以更高速的进行一些协议的通信，还有就是把设置IO的输出输出模式和上下拉模式分离了出来，多了GPIO_OType和GPIO_PuPd需要配置。<br><img src="/images/stm32_02/6.png" srcset="/img/loading.gif" alt=""></p><p>测试一下<br><img src="/images/stm32_02/7.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/8.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/9.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-代码编写"><a href="#3-代码编写" class="headerlink" title="3.代码编写"></a>3.代码编写</h2><h3 id="1-状态机编程思想"><a href="#1-状态机编程思想" class="headerlink" title="1.状态机编程思想"></a>1.状态机编程思想</h3><p>其实很多项目里面多多少少都有状态机的影子，状态机又称有限状态机，任何事物只要拥有有限个状态，就能使用状态机的方式实现代码。例如门有两种状态，即开和关，还例如我们今天要写的按键轮询检测实验中，按键的状态可以分为四种，按键弹起的状态、按键按下抖动状态、按键按下状态和按键弹起抖动状态。<br><img src="/images/stm32_02/10.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-按键基础代码编写"><a href="#2-按键基础代码编写" class="headerlink" title="2.按键基础代码编写"></a>2.按键基础代码编写</h3><p>下面我们来编写代码，首先是按键的GPIO初始化，因为我们检测的是低电平，所以设置为上拉输入。<br><img src="/images/stm32_02/11.png" srcset="/img/loading.gif" alt=""></p><p>编写引脚电平获取函数。<br><img src="/images/stm32_02/12.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/13.png" srcset="/img/loading.gif" alt=""></p><p>关于按键编号，是声明在头文件的枚举<br><img src="/images/stm32_02/14.png" srcset="/img/loading.gif" alt=""></p><p>除了按键编号与按键状态的枚举外，还有一个键值的枚举，让我们保留按键是按下，长按还是松开等等。<br><img src="/images/stm32_02/15.png" srcset="/img/loading.gif" alt=""></p><p>声明了这些枚举后，我们得用实体去接收啊，如果是C++，就是创建对象了，当然了，C语言没有对象，所以我们创建一个结构体去接收。<br><img src="/images/stm32_02/16.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/17.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-按键轮询状态机代码编写"><a href="#3-按键轮询状态机代码编写" class="headerlink" title="3.按键轮询状态机代码编写"></a>3.按键轮询状态机代码编写</h3><p>先定义触发长按的时间为1s。<br><img src="/images/stm32_02/18.png" srcset="/img/loading.gif" alt=""></p><p>开始编写三个按键一起轮询的按键检测函数，利用状态机编程。<br><img src="/images/stm32_02/19.png" srcset="/img/loading.gif" alt=""></p><p>在按键弹起状态时，如果检测到引脚为低电平，则跳转到按键按键抖动状态。<br><img src="/images/stm32_02/20.png" srcset="/img/loading.gif" alt=""></p><p>在按键按键抖动状态里，如果检测到引脚为按下时的低电平，则跳转到按键按下状态，否则则返回按键弹起状态。<br><img src="/images/stm32_02/21.png" srcset="/img/loading.gif" alt=""></p><p>在按键按下状态里，会执行长按计数，如果小于触发长按的时间里，按键松开了，则进入按键弹起抖动状态，并且保留(按键按下的键值)；如果达到触发长按的时间，就会保存(按键长按的键值，并赋值长按状态，就能一直去等待按键松开)，如果按键松开就跳转到按键弹起抖动状态。<br><img src="/images/stm32_02/22.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/23.png" srcset="/img/loading.gif" alt=""></p><p>在按键弹起抖动状态下，检测按键是不是按键弹起状态，如果是则跳转到按键弹起状态。异常状态时按键切回按键弹起状态。<br><img src="/images/stm32_02/24.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-按键轮询状态机测试"><a href="#4-按键轮询状态机测试" class="headerlink" title="4.按键轮询状态机测试"></a>4.按键轮询状态机测试</h2><h3 id="1-测试流程"><a href="#1-测试流程" class="headerlink" title="1.测试流程"></a>1.测试流程</h3><p>按键1按下，把LED1,2,3点亮；按键2按下，把LED1,2,3熄灭；按键3长按，翻转LED1,2,3。<br><img src="/images/stm32_02/25.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/26.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-代码烧录"><a href="#2-代码烧录" class="headerlink" title="2.代码烧录"></a>2.代码烧录</h3><p><img src="/images/stm32_02/27.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-实验现象"><a href="#3-实验现象" class="headerlink" title="3.实验现象"></a>3.实验现象</h3><p><img src="/images/stm32_02/28.png" srcset="/img/loading.gif" alt=""><br><img src="/images/stm32_02/29.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>STM32标准库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32标准库_01 | 搭建自己的程序框架</title>
    <link href="/2020/06/07/stm32%E6%A0%87%E5%87%86%E5%BA%93_01%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA/"/>
    <url>/2020/06/07/stm32%E6%A0%87%E5%87%86%E5%BA%93_01%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要介绍本人早期的基于STM32标准库的程序框架，希望能给人以收获。</p><h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>使用MDK5.25版本，芯片包为STM32F1系列。</p><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><p>开发板：一块STM32F103C8T6开发板（FLASH:64kBytes,RAM:20kBytes），是一款中等容量的芯片。</p><p>烧录器：STlink或者Jlink。</p><h2 id="2-工程创建"><a href="#2-工程创建" class="headerlink" title="2.工程创建"></a>2.工程创建</h2><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><p>现在本地文件夹下创建4个文件夹，分别是APP（存放应用层代码），LIB（存放STM32标准库相关文件），CORE（存放STM内核与启动文件等），Project(存放工程相关文件)。</p><p><img src="/images/stm32_01/1.png" srcset="/img/loading.gif" alt=""></p><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>在MDK中新建工程，保存到刚刚创建的本地文件夹下的Project文件夹中，并选择STM32F103芯片。</p><p><img src="/images/stm32_01/2.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/3.png" srcset="/img/loading.gif" alt=""></p><p>后面会弹出选择其他驱动组件的界面，直接选择取消。</p><p><img src="/images/stm32_01/4.png" srcset="/img/loading.gif" alt=""></p><p>接着直接用正点原子战舰板资料（推荐下载，软硬件资料很全）里面的v3.5固件库，把工程需要的文件拷贝到本地文件夹中，如图示主要是拷贝到CORE和LIB文件夹。</p><p><img src="/images/stm32_01/5.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/6.png" srcset="/img/loading.gif" alt=""></p><p>我们的LIB文件夹直接拷贝STM32战舰的参考资料\STM32F1xx固件库\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10x_StdPeriph_Driver文件夹下的inc和src这两个文件夹。</p><p><img src="/images/stm32_01/7.png" srcset="/img/loading.gif" alt=""></p><h4 id="在MDK中导入我们的文件夹结构"><a href="#在MDK中导入我们的文件夹结构" class="headerlink" title="在MDK中导入我们的文件夹结构"></a>在MDK中导入我们的文件夹结构</h4><p><img src="/images/stm32_01/8.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/9.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/10.png" srcset="/img/loading.gif" alt=""><br>在本地APP文件夹中添加main.c等文件夹（记得勾选显示文件拓展名），再添加到MDK中。<br><img src="/images/stm32_01/11.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/12.png" srcset="/img/loading.gif" alt=""></p><p>最后要指定一下头文件路径和添加全局属性的宏定义。</p><p><img src="/images/stm32_01/13.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/14.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-编写代码"><a href="#3-编写代码" class="headerlink" title="3.编写代码"></a>3.编写代码</h2><p>打开main.c添加main函数并编译</p><p><img src="/images/stm32_01/15.png" srcset="/img/loading.gif" alt=""></p><h3 id="框架代码编写"><a href="#框架代码编写" class="headerlink" title="框架代码编写"></a>框架代码编写</h3><p>（1）系统时基</p><p>当我们拿到一块STM板子的时候，我们得看它的外部晶振是多少M的（一般用8M的外部晶振），如果不是8M的晶振就需要修改stm32f10x.h和system_stm32f10x,c里的SetSysClockTo72()函数共两处地方。</p><p><img src="/images/stm32_01/16.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/17.png" srcset="/img/loading.gif" alt=""></p><p>开始编写systick.c和systick.h文件。</p><p><img src="/images/stm32_01/18.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/19.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/20.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/21.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/22.png" srcset="/img/loading.gif" alt=""></p><p>（2）编写LED程序用于测试</p><p>原理图<br><img src="/images/stm32_01/23.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/24.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/25.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/26.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/27.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/28.png" srcset="/img/loading.gif" alt=""></p><h3 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h3><p><img src="/images/stm32_01/29.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/stm32_01/30.png" srcset="/img/loading.gif" alt=""></p><h3 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h3><p><img src="/images/stm32_01/31.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>STM32标准库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
